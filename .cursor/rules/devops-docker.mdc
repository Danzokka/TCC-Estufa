---
globs: docker-compose.yml,Dockerfile*,*.dockerfile
---

# DevOps e Containerização - Docker

## Arquitetura de Containers

O sistema utiliza Docker Compose para orquestração de múltiplos serviços:

### Serviços Principais

- **api** - Backend NestJS (porta 5000)
- **web** - Frontend Next.js (porta 3000)
- **python-ia** - Serviço AI/ML Python
- **db** - PostgreSQL (porta 5433)

## Configuração Docker Compose

```yaml
version: "3.8"

services:
  api:
    build:
      context: ./apps/api
    ports:
      - "5000:5000"
    depends_on:
      - db
    environment:
      - DATABASE_URL=postgresql://postgres:postgres@db:5432/postgres
      - JWT_SECRET=your-jwt-secret

  web:
    build:
      context: ./apps/web
    ports:
      - "3000:3000"
    depends_on:
      - api
    environment:
      - NEXT_PUBLIC_API_URL=http://api:5000

  python-ia:
    build:
      context: ./apps/ai
    command: python main.py
    depends_on:
      - db
    environment:
      - DATABASE_URL=postgresql://postgres:postgres@db:5432/postgres

  db:
    image: bitnami/postgresql:latest
    environment:
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: postgres
      POSTGRES_DB: postgres
    ports:
      - "5433:5432"
    volumes:
      - postgres_data:/var/lib/postgresql/data
```

## Dockerfiles por Serviço

### Backend (NestJS)

```dockerfile
FROM node:18-alpine
WORKDIR /app
COPY package*.json ./
RUN npm ci --only=production
COPY . .
RUN npm run build
EXPOSE 5000
CMD ["npm", "run", "start:prod"]
```

### Frontend (Next.js)

```dockerfile
FROM node:18-alpine AS builder
WORKDIR /app
COPY package*.json ./
RUN npm ci
COPY . .
RUN npm run build

FROM node:18-alpine AS runner
WORKDIR /app
COPY --from=builder /app/.next ./.next
COPY --from=builder /app/public ./public
COPY --from=builder /app/package*.json ./
RUN npm ci --only=production
EXPOSE 3000
CMD ["npm", "start"]
```

### AI/ML (Python)

```dockerfile
FROM python:3.9-slim
WORKDIR /app
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt
COPY . .
EXPOSE 8000
CMD ["python", "main.py"]
```

## Variáveis de Ambiente

### Desenvolvimento

```bash
# .env.development
DATABASE_URL=postgresql://postgres:postgres@localhost:5433/postgres
JWT_SECRET=dev-secret-key
NEXT_PUBLIC_API_URL=http://localhost:5000
```

### Produção

```bash
# .env.production
DATABASE_URL=postgresql://user:password@db-host:5432/greenhouse_db
JWT_SECRET=production-secret-key
NEXT_PUBLIC_API_URL=https://api.greenhouse.com
```

## Volumes e Persistência

### Dados do Banco

- Volume nomeado `postgres_data` para persistência
- Backup automático via cron jobs
- Restore procedures documentados

### Logs e Monitoramento

- Volume compartilhado para logs
- Centralized logging com ELK stack
- Health checks para todos os serviços

## Comandos de Desenvolvimento

### Inicialização

```bash
# Desenvolvimento completo
docker-compose up -d

# Apenas banco de dados
docker-compose up -d db

# Rebuild de um serviço
docker-compose up -d --build api
```

### Debugging

```bash
# Logs em tempo real
docker-compose logs -f api

# Acesso ao container
docker-compose exec api sh

# Status dos serviços
docker-compose ps
```

## CI/CD e Deploy

### GitHub Actions

- Build automático em push
- Testes em containers
- Deploy para staging/production
- Rollback automático em falhas

### Produção

- Docker Swarm ou Kubernetes
- Load balancer para alta disponibilidade
- SSL/TLS termination
- Monitoring com Prometheus/Grafana

## Monitoramento e Logs

### Health Checks

```yaml
healthcheck:
  test: ["CMD", "curl", "-f", "http://localhost:5000/health"]
  interval: 30s
  timeout: 10s
  retries: 3
```

### Logging

- Structured logging em JSON
- Log aggregation com Fluentd
- Alertas baseados em logs
- Retention policies configuradas
